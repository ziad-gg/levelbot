import type { DeclarationReflection } from 'typedoc';
import type { ChildTypes, Config, CustomDocs, RootTypes } from './interfaces/index.js';
import { DocumentedClass } from './types/class.js';
import { DocumentedExternal } from './types/external.js';
import { DocumentedInterface } from './types/interface.js';
import { DocumentedMethod } from './types/method.js';
import { DocumentedTypeDef } from './types/typedef.js';
export declare class Documentation {
    private readonly config;
    private readonly custom?;
    readonly classes: Map<string, DocumentedClass>;
    readonly functions: Map<string, DocumentedMethod>;
    readonly interfaces: Map<string, DocumentedInterface>;
    readonly typedefs: Map<string, DocumentedTypeDef>;
    readonly externals: Map<string, DocumentedExternal>;
    constructor(data: RootTypes[] | DeclarationReflection[], config: Config, custom?: Record<string, CustomDocs> | undefined);
    parse(items: ChildTypes[] | DeclarationReflection[], p?: DeclarationReflection): void;
    serialize(): {
        meta: {
            generator: string;
            format: number;
            date: number;
        };
        classes: unknown[];
        functions: unknown[];
        interfaces: unknown[];
        typedefs: unknown[];
        externals: unknown[];
        custom: Record<string, CustomDocs> | undefined;
    };
    static get FORMAT_VERSION(): number;
}
//# sourceMappingURL=documentation.d.ts.map