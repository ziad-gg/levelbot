{"version":3,"file":"parseType.cjs","sources":["../../src/util/parseType.ts"],"sourcesContent":["import type { JSONOutput } from 'typedoc';\nimport {\n\tisArrayType,\n\tisConditionalType,\n\tisIndexedAccessType,\n\tisIntersectionType,\n\tisPredicateType,\n\tisReferenceType,\n\tisReflectionType,\n\tisLiteralType,\n\tisTupleType,\n\tisTypeOperatorType,\n\tisUnionType,\n\tisQueryType,\n\tisInferredType,\n\tisIntrinsicType,\n\tisUnknownType,\n} from './types';\n\nexport function parseType(t: JSONOutput.SomeType | JSONOutput.Type | string): string {\n\tif (typeof t === 'string') {\n\t\treturn t;\n\t}\n\n\tif (isArrayType(t)) {\n\t\treturn `Array<${parseType(t.elementType)}>`;\n\t}\n\n\tif (isConditionalType(t)) {\n\t\tconst { checkType, extendsType, trueType, falseType } = t;\n\t\treturn `${parseType(checkType)} extends ${parseType(extendsType)} ? ${parseType(trueType)} : ${parseType(\n\t\t\tfalseType,\n\t\t)}`;\n\t}\n\n\tif (isIndexedAccessType(t)) {\n\t\treturn `${parseType(t.objectType)}[${parseType(t.indexType)}]`;\n\t}\n\n\tif (isIntersectionType(t)) {\n\t\treturn t.types.map(parseType).join(' & ');\n\t}\n\n\tif (isPredicateType(t)) {\n\t\treturn (t.asserts ? 'asserts ' : '') + t.name + (t.targetType ? ` is ${parseType(t.targetType)}` : '');\n\t}\n\n\tif (isReferenceType(t)) {\n\t\treturn t.name + (t.typeArguments ? `<${t.typeArguments.map(parseType).join(', ')}>` : '');\n\t}\n\n\tif (isReflectionType(t)) {\n\t\tconst obj: Record<string, any> = {};\n\n\t\tconst { children, signatures } = t.declaration!;\n\n\t\t// This is run when we're parsing interface-like declaration\n\t\tif (children && children.length > 0) {\n\t\t\tfor (const child of children) {\n\t\t\t\tconst { type } = child;\n\t\t\t\tif (type) {\n\t\t\t\t\tobj[child.name] = parseType(type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn `{\\n${Object.entries(obj)\n\t\t\t\t.map(([key, value]) => `${key}: ${value as string}`)\n\t\t\t\t.join(',\\n')}\\n}`;\n\t\t}\n\n\t\t// This is run if we're parsing a function type\n\t\tif (signatures && signatures.length > 0) {\n\t\t\tconst s = signatures[0];\n\t\t\tconst params = s?.parameters?.map((p) => `${p.name}: ${p.type ? parseType(p.type) : 'unknown'}`);\n\t\t\treturn `(${params?.join(', ') ?? '...args: unknown[]'}) => ${s?.type ? parseType(s.type) : 'unknown'}`;\n\t\t}\n\n\t\treturn '{}';\n\t}\n\n\tif (isLiteralType(t)) {\n\t\tif (typeof t.value == 'string') {\n\t\t\treturn `'${t.value}'`;\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t\treturn `${t.value}`;\n\t}\n\n\tif (isTupleType(t)) {\n\t\treturn `[${(t.elements ?? []).map(parseType).join(', ')}]`;\n\t}\n\n\tif (isTypeOperatorType(t)) {\n\t\treturn `${t.operator} ${parseType(t.target)}`;\n\t}\n\n\tif (isUnionType(t)) {\n\t\treturn t.types\n\t\t\t.map(parseType)\n\t\t\t.filter((s) => Boolean(s) && s.trim().length > 0)\n\t\t\t.join(' | ');\n\t}\n\n\tif (isQueryType(t)) {\n\t\treturn `(typeof ${parseType(t.queryType)})`;\n\t}\n\n\tif (isInferredType(t) || isIntrinsicType(t) || isUnknownType(t)) {\n\t\treturn t.name;\n\t}\n\n\treturn 'unknown';\n}\n"],"names":["y","o","a","u","f","T","c","m","$","l","g","d","j","O","h"],"mappings":"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"}