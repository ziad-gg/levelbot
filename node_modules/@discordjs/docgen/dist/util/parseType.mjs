import{isArrayType as y,isConditionalType as o,isIndexedAccessType as a,isIntersectionType as T,isPredicateType as u,isReferenceType as f,isReflectionType as $,isLiteralType as c,isTupleType as m,isTypeOperatorType as l,isUnionType as g,isQueryType as d,isInferredType as j,isIntrinsicType as k,isUnknownType as h}from"./types.mjs";function n(e){if(typeof e=="string")return e;if(y(e))return`Array<${n(e.elementType)}>`;if(o(e)){const{checkType:i,extendsType:p,trueType:s,falseType:t}=e;return`${n(i)} extends ${n(p)} ? ${n(s)} : ${n(t)}`}if(a(e))return`${n(e.objectType)}[${n(e.indexType)}]`;if(T(e))return e.types.map(n).join(" & ");if(u(e))return(e.asserts?"asserts ":"")+e.name+(e.targetType?` is ${n(e.targetType)}`:"");if(f(e))return e.name+(e.typeArguments?`<${e.typeArguments.map(n).join(", ")}>`:"");if($(e)){const i={},{children:p,signatures:s}=e.declaration;if(p&&p.length>0){for(const t of p){const{type:r}=t;r&&(i[t.name]=n(r))}return`{
${Object.entries(i).map(([t,r])=>`${t}: ${r}`).join(`,
`)}
}`}if(s&&s.length>0){const t=s[0];return`(${t?.parameters?.map(r=>`${r.name}: ${r.type?n(r.type):"unknown"}`)?.join(", ")??"...args: unknown[]"}) => ${t?.type?n(t.type):"unknown"}`}return"{}"}return c(e)?typeof e.value=="string"?`'${e.value}'`:`${e.value}`:m(e)?`[${(e.elements??[]).map(n).join(", ")}]`:l(e)?`${e.operator} ${n(e.target)}`:g(e)?e.types.map(n).filter(i=>Boolean(i)&&i.trim().length>0).join(" | "):d(e)?`(typeof ${n(e.queryType)})`:j(e)||k(e)||h(e)?e.name:"unknown"}export{n as parseType};
//# sourceMappingURL=parseType.mjs.map
