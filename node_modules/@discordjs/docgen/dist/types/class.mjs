import{parse as h}from"node:path";import{DocumentedConstructor as p}from"./constructor.mjs";import{DocumentedEvent as l}from"./event.mjs";import{DocumentedItemMeta as r}from"./item-meta.mjs";import{DocumentedItem as u}from"./item.mjs";import{DocumentedMember as f}from"./member.mjs";import{DocumentedMethod as v}from"./method.mjs";import{DocumentedVarType as m}from"./var-type.mjs";import{parseType as c}from"../util/parseType.mjs";class g extends u{constructor(e,i){if(super(e,i),this.props=new Map,this.methods=new Map,this.events=new Map,this.construct=null,this.extends=null,this.implements=null,i.typescript){const s=e,a=s.extendedTypes?.[0];a&&(this.extends=new m({names:[c(a)]},this.config));const n=s.implementedTypes?.[0];n&&(this.implements=new m({names:[c(n)]},this.config))}else{const s=e;s.augments&&(this.extends=new m({names:s.augments},this.config)),s.implements&&(this.implements=new m({names:s.implements},this.config))}}add(e){if(e instanceof p){if(this.construct)throw new Error(`Doc ${this.data.name} already has constructor`);this.construct=e}else if(e instanceof v){const i=e.data.scope==="static"||e.data.flags?.isStatic?"s-":"";if(this.methods.has(i+e.data.name))throw new Error(`Doc ${this.data.name} already has method ${e.data.name}`);this.methods.set(i+e.data.name,e)}else if(e instanceof f){if(this.props.has(e.data.name))throw new Error(`Doc ${this.data.name} already has prop ${e.data.name}`);this.props.set(e.data.name,e)}else if(e instanceof l){if(this.events.has(e.data.name))throw new Error(`Doc ${this.data.name} already has event ${e.data.name}`);this.events.set(e.data.name,e)}}serializer(){if(this.config.typescript){const i=this.data,s=(i.signatures??[])[0]??i;let a;const n=i.sources?.[0];n&&(a=new r(n,this.config).serialize());const d=s.comment?.blockTags?.filter(t=>t.tag==="@see").length?s.comment.blockTags.filter(t=>t.tag==="@see").map(t=>t.content.find(o=>o.kind==="text")?.text.trim()):void 0;return{name:s.name==="default"?h(a?.file??"default").name:s.name,description:s.comment?.summary.reduce((t,o)=>t+=o.text,"").trim()||void 0,see:d,extends:this.extends?.serialize(),implements:this.implements?.serialize(),access:i.flags.isPrivate||s.comment?.blockTags?.some(t=>t.tag==="@private"||t.tag==="@internal")?"private":void 0,abstract:s.comment?.blockTags?.some(t=>t.tag==="@abstract")||void 0,deprecated:s.comment?.blockTags?.some(t=>t.tag==="@deprecated")?s.comment.blockTags.find(t=>t.tag==="@deprecated")?.content.reduce((t,o)=>t+=o.text,"").trim()??!0:void 0,construct:this.construct?.serialize(),props:this.props.size?[...this.props.values()].map(t=>t.serialize()):void 0,methods:this.methods.size?[...this.methods.values()].map(t=>t.serialize()):void 0,events:this.events.size?[...this.events.values()].map(t=>t.serialize()):void 0,meta:a}}const e=this.data;return{name:e.name,description:e.description,see:e.see,extends:this.extends?.serialize(),implements:this.implements?.serialize(),access:e.access,abstract:e.virtual,deprecated:e.deprecated,construct:this.construct?.serialize(),props:this.props.size?[...this.props.values()].map(i=>i.serialize()):void 0,methods:this.methods.size?[...this.methods.values()].map(i=>i.serialize()):void 0,events:this.events.size?[...this.events.values()].map(i=>i.serialize()):void 0,meta:new r(e.meta,this.config).serialize()}}}export{g as DocumentedClass};
//# sourceMappingURL=class.mjs.map
